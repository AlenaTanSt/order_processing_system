# Этап 01. Многопоточная обработка заказов

## Цель этапа

Реализовать **многопоточную обработку заказов** на основе уже существующего однопоточного pipeline, обеспечив:

* корректную работу в условиях конкурентного доступа;
* отсутствие гонок данных и UB;
* корректный жизненный цикл потоков;
* воспроизводимые и проверяемые метрики.

---

## Ключевая идея этапа

На этом этапе **pipeline работает пакетно**:

* заказы **принимаются** через `submit`;
* затем вызывается `process_all`;
* `process_all`:

  * блокирует новые `submit`;
  * параллельно обрабатывает все ранее принятые заказы;
  * полностью завершается;
* после этого pipeline снова готов принимать заказы.

**Никакой “live-обработки” в этом этапе нет.**

## Ограничения

Запрещено:

* `std::atomic`;
* `std::condition_variable`;
* lock-free структуры;
* изменение публичного интерфейса `Order`.

Разрешено и ожидается:

* `std::mutex`, `std::lock_guard`, `std::scoped_lock`;
* `std::jthread` **или** RAII-обертка над `std::thread`;
* `std::thread::hardware_concurrency`;
* обычные контейнеры STL.

---

## Файлы этапа

Используются и расширяются **только** следующие файлы:

* `order.hpp` (без изменений интерфейса);
* `queue.hpp`;
* `pipeline.hpp`;
* `metrics.hpp`.

Добавление вспомогательных классов **внутри этих файлов** допускается, но все взаимодействие между классами идет через заданный интерфейс из задания.

---

## Часть 1. Потокобезопасная очередь заказов

### Файл: `queue.hpp`

Необходимо реализовать **потокобезопасную очередь заказов**, которая будет использоваться pipeline.

### Обязательный интерфейс

```cpp
class OrderQueue {
public:
    void push(Order order);
    bool try_pop(Order& out);
    bool empty() const;

private:
    std::queue<Order> queue_;
    mutable std::mutex mutex_;
};
```

### Обязательная семантика

* `push`:

  * добавляет заказ в очередь;
  * всегда успешен;
* `try_pop`:

  * возвращает `false`, если очередь пуста;
  * иначе извлекает **ровно один** заказ и возвращает `true`;
* `empty`:

  * потокобезопасен;
  * **запрещено** использовать для управления завершением worker-потоков.

Очередь **не должна**:

* отдавать ссылки или указатели на внутренние данные;
* содержать какую-либо логику ожидания.

---

## Часть 2. Pipeline

### Файл: `pipeline.hpp`

```cpp
class Pipeline {
public:
    void submit(Order order);
    void process_all();
    Metrics metrics() const;
    const std::vector<Order>& delivered_orders() const;

private:
    OrderQueue queue_;
    Metrics metrics_;
    std::vector<Order> delivered_;

    std::mutex submit_mutex_;
};
```

---

## Часть 3. Семантика submit / process_all

### submit

* потокобезопасен;
* каждый вызов:

  * увеличивает `accepted_count`;
  * добавляет заказ в очередь;
* если в данный момент выполняется `process_all`,
  **submit блокируется** до его завершения.

### process_all

* блокирует все вызовы `submit` на время выполнения;
* обрабатывает **только те заказы**, которые были приняты **до начала** `process_all`;
* после возврата:

  * очередь пуста;
  * все заказы обработаны;
  * метрики и `delivered_orders()` больше не меняются.

Повторный вызов `process_all` при пустой очереди:

* допустим;
* не изменяет состояние pipeline.

---

## Часть 4. Рабочие потоки

### Создание потоков

* `process_all` **всегда создает N потоков**, где
  `N = max(1, std::thread::hardware_concurrency())`.

### Работа worker-потока

Каждый worker выполняет цикл:

1. пытается извлечь заказ через `try_pop`;
2. если заказ получен:

   * увеличивает `processed_count`;
   * обрабатывает заказ;
   * увеличивает `delivered_count`;
   * добавляет заказ в `delivered_`;
3. если `try_pop` вернул `false` - поток завершает работу.

### Гарантии

* каждый заказ извлекается из очереди **ровно один раз**;
* каждый заказ обрабатывается **ровно одним потоком**;
* ни один заказ не может быть потерян или обработан повторно.

---

## Часть 5. Метрики

### Файл: `metrics.hpp`

```cpp
struct Metrics {
    std::uint64_t accepted_count = 0;
    std::uint64_t processed_count = 0;
    std::uint64_t delivered_count = 0;
    std::chrono::nanoseconds total_processing_time{0};
};
```

### Обязательная семантика

* `delivered_orders().size() == delivered_count`;
* `total_processing_time` =
  сумма `(delivered_time - accepted_time)` по всем доставленным заказам.

### Потокобезопасность

* все обновления метрик обязаны быть защищены от гонок;
* `Pipeline::metrics()` возвращает **консистентный snapshot**.

---

## Часть 6. Жизненный цикл потоков

Pipeline **обязан**:

* дождаться завершения всех worker-потоков перед возвратом из `process_all`;
* не допускать `std::terminate`;
* корректно работать при исключениях.

---

## Часть 7. Что именно проверяется тестами

Тесты **обязательно проверяют**:

* отсутствие потерь и дублей заказов;
* корректность всех счетчиков;
* корректность `total_processing_time`;
* идемпотентность `process_all`;
* блокировку `submit` во время обработки;
* корректное завершение потоков.